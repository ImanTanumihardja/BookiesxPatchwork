"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseJson = void 0;
const contractSchema_1 = require("./contractSchema");
function parseJson(jsonData) {
    let contractConfig = {
        scopeName: jsonData.scopeName,
        name: jsonData.name,
        symbol: jsonData.symbol,
        baseURI: jsonData.baseURI,
        schemaURI: jsonData.schemaURI,
        imageURI: jsonData.imageURI,
        fields: parseFieldEntries(jsonData),
        features: parseFeatures(jsonData),
    };
    return new contractSchema_1.ContractSchemaImpl(contractConfig);
}
exports.parseJson = parseJson;
function parseFeatures(jsonData) {
    let features = [];
    if (jsonData.features && Array.isArray(jsonData.features)) {
        features = jsonData.features.map((featureName) => {
            // Convert the feature name to uppercase for case-insensitive comparison
            const normalizedFeatureName = featureName.toUpperCase();
            // Find the matching enum key, considering case-insensitivity
            const matchingKey = Object.keys(contractSchema_1.Feature).find((key) => contractSchema_1.Feature[key].toUpperCase() === normalizedFeatureName);
            if (!matchingKey) {
                throw new Error(`Feature not found: ${featureName}`);
            }
            return contractSchema_1.Feature[matchingKey];
        });
    }
    return features;
}
function parseFieldEntries(jsonData) {
    return jsonData.fields.map((field, index) => {
        const fieldArrayLength = field.arrayLength === undefined ? 1 : field.arrayLength;
        const entry = {
            id: field.id,
            permissionId: field.permissionId,
            fieldType: field.type,
            arrayLength: fieldArrayLength,
            visibility: "FieldVisibility.PUBLIC",
            key: field.key,
            description: field.description,
        };
        return entry;
    });
}
