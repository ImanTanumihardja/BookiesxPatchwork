"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const contractSchemaJsonParser_1 = require("./contractSchemaJsonParser");
const mainContractGen_1 = require("./mainContractGen");
describe('generateSolidityCode', () => {
    const testDirectory = './src/test_data';
    const files = fs_1.default.readdirSync(testDirectory);
    const jsonFiles = files.filter((file) => file.endsWith('.json'));
    const solFiles = files.filter((file) => file.endsWith('.sol'));
    const gen = new mainContractGen_1.MainContractGen();
    const groupedFiles = jsonFiles.reduce((acc, jsonFile) => {
        const baseName = path_1.default.basename(jsonFile, '.json');
        acc[baseName] = {
            json: path_1.default.join(testDirectory, jsonFile),
            sol: path_1.default.join(testDirectory, baseName + '.sol'),
        };
        return acc;
    }, {});
    for (const [baseName, files] of Object.entries(groupedFiles)) {
        if (solFiles.includes(baseName + '.sol')) {
            it(`should generate the correct Solidity code for ${baseName}.json`, () => {
                const jsonData = JSON.parse(fs_1.default.readFileSync(files.json, 'utf8'));
                const solidityExpected = fs_1.default.readFileSync(files.sol, 'utf8');
                const solidityGenerated = gen.gen((0, contractSchemaJsonParser_1.parseJson)(jsonData));
                expect(solidityGenerated).toEqual(solidityExpected);
            });
        }
    }
});
