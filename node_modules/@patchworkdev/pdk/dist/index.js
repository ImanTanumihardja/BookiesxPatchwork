#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _2019_1 = __importDefault(require("ajv/dist/2019"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const helpers_1 = require("yargs/helpers");
const yargs_1 = __importDefault(require("yargs/yargs"));
const contractSchemaJsonParser_1 = require("./contractSchemaJsonParser");
const mainContractGen_1 = require("./mainContractGen");
const jsonSchemaGen_1 = require("./jsonSchemaGen");
const argv = (0, yargs_1.default)((0, helpers_1.hideBin)(process.argv))
    .command("validate <jsonFile>", "Validate a JSON metadata schema file", (yargs) => {
    yargs.positional("jsonFile", {
        describe: "Path to the JSON file",
        type: "string",
    });
}, validateJson)
    .command("generate <jsonFile>", "Generate NFT source", (yargs) => {
    yargs
        .positional("jsonFile", {
        describe: "Path to the JSON file",
        type: "string",
    })
        .option("output", {
        alias: "o",
        type: "string",
        description: "Output directory for the generated Solidity file",
    });
}, generateSolidity)
    .demandCommand(1, "You must provide a valid command")
    .help("h")
    .alias("h", "help")
    .argv;
function tryValidate(jsonFile, schemaFile) {
    try {
        const jsonData = require(path_1.default.resolve(jsonFile));
        const schemaData = require(schemaFile);
        const ajv = new _2019_1.default();
        const validate = ajv.compile(schemaData);
        if (validate(jsonData)) {
            return true;
        }
        return validate.errors;
    }
    catch (error) {
        console.error("Error reading JSON or schema file:", error.message);
    }
}
function validateJson(argv) {
    const jsonFile = argv.jsonFile;
    const t1 = tryValidate(jsonFile, "../src/patchwork-contract-config.schema.json");
    // TODO need separate commands to validate metadata schemas as one can bury errors in the other
    //const t2 = tryValidate(jsonFile, "../src/patchwork-metadata.schema.json")
    if (t1 === true) {
        console.log("The JSON file is a valid Patchwork contract configuration.");
    }
    else {
        console.log("The JSON file is not a valid Patchwork contract config");
        console.log("Contract Config Validation Errors:", t1);
        // console.log("Metadata Schema Validation Errors:", t2);
    }
}
function generateSolidity(argv) {
    const jsonFile = argv.jsonFile;
    const outputDir = argv.output || process.cwd();
    try {
        const jsonData = require(path_1.default.resolve(jsonFile));
        const schema = (0, contractSchemaJsonParser_1.parseJson)(jsonData);
        schema.validate();
        const solidityCode = new mainContractGen_1.MainContractGen().gen(schema);
        const solidityFilename = path_1.default.basename(jsonFile, ".json") + ".sol";
        let outputPath = path_1.default.join(outputDir, solidityFilename);
        fs_1.default.writeFileSync(outputPath, solidityCode);
        console.log(`Solidity file generated at ${outputPath}`);
        const jsonSchema = new jsonSchemaGen_1.JSONSchemaGen().gen(schema);
        const jsonFilename = path_1.default.basename(jsonFile, ".json") + "-schema.json";
        outputPath = path_1.default.join(outputDir, jsonFilename);
        fs_1.default.writeFileSync(outputPath, jsonSchema);
        console.log(`JSON Schema file generated at ${outputPath}`);
    }
    catch (error) {
        console.error("Error generating Solidity file:", error.message);
    }
}
